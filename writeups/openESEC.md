# openESEC


## crypto
### mind-the-gap
```
from gmpy2 import *
N = 14508309593146392036852186367486607754388239123770045829691243154184222998048687640251024592386635569441697046704926723488988355327326504615470145691018948327744499406122769019271226177020244314074490750904060591894303295727249862117568649114289768761885684370964884412426733979181999870253163142239463480329828176240372814784781649967949154525845673601892717561048122900031676770493961212911406501893741411348182441940092726196645991558760193347770520388625214322511344330370596664171127419549482767572865387681019052778209128714326125730339472096608481806721227870805240691046645666979003932603432396724282042435777
e = 3
c = 5046000458278559117779134957838044135098690309585755353058261138276193482137505781482132564608553106896440785493291347385933317040883078691311015088213452902618633863936122902317586074609303885727206126845881797705002735528996492104140693057150294744361533364414645613312759904419925520873230926724120921268840005047605100307811214696752571329125
prefix = "openECSC{mind_the_gap_"


m, exact = iroot(c, e)
plaintext = bytes.fromhex(hex(m)[2:]).decode()
flag = prefix + plaintext[len(prefix):]  
print(flag)
```


## rev
### mvmory
```
import math
from pathlib import Path

LEDGER = [
    0x4D8F3A691D646EB3, 0x4D8F3AA71D646C74, 0x4D8F3AA61D646C32,
    0x4D8F3BDB1D646A10, 0x4D8F3B971D646DA4, 0x4D8F3A0A1D646C00,
    0x4D8F3A731D646E90, 0x4D8F3A751D646F7D, 0x4D8F3B981D646CA8,
    0x4D8F3B391D646D60, 0x4D8F3A3F1D6469BD, 0x4D8F3A8E1D646DBA,
    0x4D8F3B311D646C3C, 0x4D8F3AF41D646E60, 0x4D8F3B8D1D646AD8,
    0x4D8F3A231D646D4C, 0x4D8F3A9E1D646C48, 0x4D8F3B391D646A4C,
    0x4D8F3AC41D646DE5, 0x4D8F38001D646CC4, 0x4D8F3A7C1D646DA6,
    0x4D8F3AE61D646B7A, 0x4D8F3B751D646E6D, 0x4D8F3B5D1D646DA4,
    0x4D8F3B4D1D646D0B, 0x4D8F3A691D646C50, 0x4D8F3AF11D646E72,
    0x4D8F3A2A1D646E08, 0x4D8F3BD11D646B20, 0x4D8F3B421D646CE6,
    0x4D8F3A341D646D70, 0x4D8F3AA51D646B76, 0x4D8F3A3F1D646D97,
    0x4D8F3B7A1D646EF8, 0x4D8F381A1D646C34, 0x4D8F3A601D646D10,
    0x4D8F3AC31D646BDC, 0x4D8F3AA11D646E68, 0x4D8F3BB61D646BD8,
    0x4D8F3B031D646CC4, 0x4D8F3A591D646EDB, 0x4D8F3AB01D646CA8,
    0x4D8F3AD21D646E56
]

KEY = [0x52, 0x0F, 0x33, 0x08, 0x19, 0x27, 0x44]

CONST1 = 0x4D8F3A51E29B907C
CONST_MULT = 0xCCCCCCCCCCCCCCCD
MASK64 = (1 << 64) - 1


def high64_of_mul(a, b):
    return (a * b >> 64) & MASK64


def to_signed32(x):
    x &= 0xFFFFFFFF
    return x - 0x100000000 if (x & 0x80000000) else x


def compute_s2(ledger):
    if len(ledger) != 43:
        raise SystemExit('ledger must have 43 entries')
    s2 = bytearray(43)
    v3 = 0.0
    for i in range(43):
        term = high64_of_mul(CONST_MULT, i) & 0xFFFFFFFFFFFFFFFC
        v5 = i // 5 + term
        v6 = float(i - int(v5) + 1)

        high32 = ((ledger[i] ^ CONST1) >> 32) & 0xFFFFFFFF
        v7 = -to_signed32(high32)
        v8 = float(v7)

        low32 = ledger[i] & 0xFFFFFFFF
        right_term = to_signed32(low32 ^ 0xE29B907C)

        D = v8 * v8 - v6 * 4.0 * float(right_term)

        if D < 0.0:
            val = 0.0
        else:
            sqrtD = math.sqrt(D)
            val = (sqrtD - v8) / (v6 + v6)
            if val < v3:
                val = -val

        b = 0 if math.isnan(val) else int(math.floor(val + 0.5))
        s2[i] = b & 0xFF
    return bytes(s2)


def recover_input(s2, key):
    out = bytearray(len(s2))
    for i, b in enumerate(s2):
        out[i] = b ^ key[i % len(key)]
    return bytes(out)


if __name__ == '__main__':
    s2 = compute_s2(LEDGER)
    recovered = recover_input(s2, KEY)
    print('flag (text):', recovered.decode('utf-8'))

```